'''
Created on Jun 19, 2015

@author: Tyler P
'''
import sys, os
from optparse import OptionParser
import json
import datetime

verbose = 0

class Keys:
    """Container class for the options' key strings
    @see binding_ensemble_parameters()
    """
    # Useful options file information (TODO: yet to be implemented)
    COMMENTS = dict()  # key from above, maps to useful comment
    SECTIONS = dict()  # title of section from above, maps to list of keys

    # Values that can be specified by the user in the options file
    ################################################
    # General
    base_name = 'base-name'
    job_name = 'job-name'
    work_dir = 'sim-dir'
    script_dir = 'scripts-dir'
    ligand = 'ligand-res-name'
    SECTIONS['General'] = [base_name, job_name, work_dir, script_dir, ligand]
    COMMENTS[base_name] = ('Name to prefix all files')
    ################################################
    # MDP
    sim_time = 'sim-time-ns'
    sim_weights = 'sim-initial-weights'
    sim_fixed_weights = 'sim-fixed-weights'
    sim_weight_values = 'sim-value-of-weights'
    sim_incrementor = 'sim-weight-incrementor'
    sim_fixed_lambda = 'sim-init-lambda-only_no-expdens'
    SECTIONS['Simulation'] = [sim_time, sim_weights, sim_fixed_weights,
        sim_weight_values, sim_incrementor, sim_fixed_lambda]
    ################################################
    # Sim Array
    mdr_count = 'mdr-number-of-simulations'
    mdr_threads = 'mdr-number-of-threads'
    mdr_queue_time = 'mdr-queue-time'
    mdr_genseed = 'mdr-generate-seeds'
    SECTIONS['mdrun Array'] = [mdr_count, mdr_threads, mdr_queue_time,
        mdr_genseed]
    COMMENTS[mdr_threads] = ('Max 20 threads (for now)')
    ################################################
    # Process Control
    verbosity = 'verbose-level'
    setup_simarray = 'setup-array-of-jobs'
    setup_mdp = 'create-mdp'
    SECTIONS['Process Control'] = [verbosity, setup_simarray, setup_mdp]

    # Internally calculated values
KEYS = Keys()

def _com_char():
    """ Comment character for param files
    """
    return '#'

def _sep_char():
    """ Separation character for param files
    """
    return '='

def _file_ext():
    """File extension for param files
    """
    return '.par'

def _arrange_options(options, sections_dict=KEYS.SECTIONS):
    """Arranges the options that are present so that they print in section-order
    """
    arrange = dict()
    misc = []
    for key in sorted(options):
        placed = False
        for section in sections_dict:
            if key in sections_dict[section]:
                if not section in arrange:
                    arrange[section] = []
                arrange[section].append(key)
                placed = True
                break
        if not placed:
            misc.append(key)
    return arrange, misc

def write_options(optionsFile, options, sections_dict=KEYS.SECTIONS,
    comments_dict=KEYS.COMMENTS):
    """Write all the options used during analysis, so that it is clear for the
    user to double check.
    
    The inspiration for this procedure is taken from the GROMACS simulation
    package, and the file type .mdp
    
    @organization: Shirts Group
    @author: Tyler P
    @param optionsFile: (String) location of the configuration file (.bep)
    @param options: (dict) configuration parameters    
    """

    enc = json.JSONEncoder()
    sep = _sep_char()
    com = _com_char()
    format_ = '{0:<40}'

    arrangement, others = _arrange_options(options, sections_dict)

    file_out = open(optionsFile, 'w')
    file_out.write(com + "Generated by " + os.path.basename(__file__) + " @ " +
        str(datetime.datetime.now()) + '\n')
    file_out.write(com + "    Variables beginning with an underscore (_) are" +
        " calculated by the program, and are\n")
    file_out.write(com + "    only included here for reference. Their values" +
        " will be overwritten on file read.\n")
    for section in arrangement:
        if arrangement[section]:
            file_out.write(com + '##{0:#>35}###\n'.format(''))
            file_out.write(com + '##{0:^35}###\n'.format(section))
            for key in arrangement[section]:
                if key in comments_dict:
                    comment = comments_dict[key].splitlines()
                    for line in comment:
                        file_out.write(com + ' ' + line + '\n')
                file_out.write(format_.format(key) + sep + ' ' +
                    enc.encode(options[key]) + '\n')
    if others:
        file_out.write('\n')
        file_out.write(com + '##{0:#>35}###\n'.format(''))
        for key in others:
            if key in comments_dict:
                comment = comments_dict[key].splitlines()
                for line in comment:
                    file_out.write(com + ' ' + line + '\n')
            file_out.write(format_.format(key) + sep + ' ' +
                enc.encode(options[key]) + '\n')
    file_out.close()

def parse_options(optionsFile, options=None):
    """Read contents of a configuration file, which provides input for the 
    algorithms of binding ensemble analysis. 
    
    The inspiration for this procedure is taken from the GROMACS simulation
    package, and the file type .mdp
    
    @organization: Shirts Group
    @author: Tyler P
    @param optionsFile: (String) location of the configuration file (.bep)
    @param options: (dict) optional dictionary to store the options. If None, 
        a dictionary of default values will be generated. Otherwise, the return
        value is this dict with the options from file added.
    @see: bindingEnsembleParameters()
    
    @return: dict, with the options from file added
    """

    sep = _sep_char()
    com = _com_char()
    dec = json.JSONDecoder()

    if not options:
        options = option_defaults()

    file_ = open(optionsFile, 'r')
    if file_:
        for line in file_:
            # comments denoted with hashmark
            if com in line:
                line = line.split(com)[0]
            # name of parameter is followed by a colon
            line = line.strip()
            if sep in line:
                colon = line.split(sep)
                key = colon[0]
                value = line.replace(key + sep, '')
                key = key.strip()
                value = value.strip()
                options[key] = dec.decode(value)
    else:
        options = None

    return options

def option_defaults():
    """Define the default parameters for param file.
    
    The inspiration for this procedure is taken from the GROMACS simulation
    package, and the file type .mdp

    @organization: Shirts Group
    @author: Tyler P
    
    @return: dict containing all possible options, and their default values
    """

    options = dict()

    # To help avoid spelling errors, the keys are kept in a container object,
    #    and each use of that key points back to the string listed there.
    options[KEYS.base_name] = None
    options[KEYS.job_name] = None
    options[KEYS.work_dir] = '.'
    options[KEYS.script_dir] = '.'
    options[KEYS.ligand] = 'TMP'
    options[KEYS.verbosity] = 1  # Change output frequency and detail
    options[KEYS.setup_simarray] = False
    options[KEYS.setup_mdp] = False
    options[KEYS.sim_time] = 0.2  # ns
    options[KEYS.sim_weights] = False
    options[KEYS.sim_fixed_weights] = False
    options[KEYS.sim_weight_values] = []
    options[KEYS.sim_incrementor] = 1
    options[KEYS.sim_fixed_lambda] = False
    options[KEYS.mdr_count] = 1
    options[KEYS.mdr_threads] = 10
    options[KEYS.mdr_queue_time] = '1-00:00:00'
    options[KEYS.mdr_genseed] = False

    return options

def _backup_name(path, filename, counter):
    """ Default method of assigning a backup name
    """
    filename = '~' + filename + '.' + str(counter) + '~'
    return os.path.join(path, filename)

def backup_file(directory, filename):
    """ Backup an Analysis File
    
    The inspiration for this procedure is taken from the GROMACS simulation
    package, which backs up its .mdp files (and others) in similar manner

    @organization: Shirts Group
    @author: Tyler P
    
    @return: the result of os.path.join(directory, filename), where this file,
        if it already existed, has been moved to a backup file
    """
    fileOut = os.path.join(directory, filename)
    if os.path.exists(fileOut):
        count = 1
        backupName = _backup_name(directory, filename, count)
        while os.path.exists(backupName):
            count += 1
            backupName = _backup_name(directory, filename, count)
        if verbose >= 0:
            print('Backing up ' + filename + ' to ' + backupName)
        os.rename(fileOut, backupName)
    return fileOut

def expandpath(path):
    return os.path.realpath(os.path.expanduser(os.path.expandvars(path)))

#################################################################################
#################################################################################

def place_simarray_vars(fields):
    fields['outputfile'] = os.path.join(fields['path'], fields['job-name'] +
        fields['suffix'], fields['job-name'])
    fields['workdir'] = os.path.join(fields['path'], fields['job-name'] +
        fields['suffix'])
    fields['infolder'] = os.path.join('..', '')
    fields['jobstatus'] = os.path.join('..', 'jobstatus.txt')

    text_ = """#!/bin/sh
#SBATCH --job-name={job-name}{suffix}
#SBATCH --partition=serial
#SBATCH --nodes=1
#SBATCH --ntasks={ntasks}
#SBATCH --time={queue-time}
#SBATCH --signal=15 --comment="15 = SIGTERM"
#SBATCH --output={outputfile}.out
#SBATCH --workdir={workdir}
#SBATCH --checkpoint=06:00:00
#SBATCH --checkpoint-dir=/scratch/jtp4kc/checkpoints
#SBATCH --mail-type=ALL
#SBATCH --mail-user=jtp4kc@virginia.edu
#SBATCH --comment="#SBATCH --array-0,1,3"

# submit a single SLURM job for a free energy calc
module load gromacs/5.0.2-sse
export THREADINFO="-nt {ntasks} "
export GMX_SUPPRESS_DUMP=1 #prevent step file output when parameters don't converge

#export OMP_NUM_THREADS={ntasks}

sleep 1

#Change the job status to 'SUBMITTED'
echo "SUBMITTED {job-name}{suffix} `date`" >> {jobstatus}
echo "Job Started at `date`"

#NVT PRODUCTION
grompp_d -c {infolder}{gro-in}-in.gro -p {infolder}{base}.top -n {infolder}{base}.ndx -f {mdp-in}.mdp -o {job-name}.tpr -maxwarn 15
mdrun_d ${{THREADINFO}} -deffnm {job-name}

echo "FINISHED {job-name}{suffix} `date`" >> {jobstatus}
# print end time
echo
echo "Job Ended at `date`"
echo "###################################################################"
""".format(**fields)

    return text_

def place_simarray_mdp_vars(fields):
    fields['dt'] = 0.002;  # ps
    fields['nstrun'] = fields['time-ns'] * (1000 / fields['dt'])

    fields['fep-lambdas'] = ''
    fields['coul-lambdas'] = ''
    fields['vdw-lambdas'] = ''
    for f, c, v in zip(fields['fep'], fields['coul'], fields['vdw']):
        fields['fep-lambdas'] += '{0:0.1f} '.format(f)
        fields['coul-lambdas'] += '{0:0.1f} '.format(c)
        fields['vdw-lambdas'] += '{0:0.1f} '.format(v)

    fields['wl-weights'] = ''

    if fields['initial-weights']:
        for w in fields['weights']:
            fields['wl-weights'] += '{0:0.5f} '.format(w)
        if not len(fields['fep']) == len(fields['weights']):
            print('Number of weights not equal to number of states, please' +
                ' address')
        fields['ilw'] = ''
    else:
        fields['ilw'] = '; '

    if fields['fixed-weights'] and fields['initial-weights']:
        fields['weights-equil'] = 'yes'
        fields['wed'] = '; '
    else:
        fields['weights-equil'] = 'wl-delta'
        fields['wed'] = ''

    if fields['fixed-lambda']:
        fields['free-energy-flag'] = 'yes'
    else:
        fields['free-energy-flag'] = 'expanded'

    text_ = """; RUN CONTROL PARAMETERS = 
integrator               = md-vv
; start time and timestep in ps = 
tinit                    = 0
dt                       = {dt:0.3f}
nsteps                   = {nstrun:<12.0f}; {time-ns:0.2f} ns
; mode for center of mass motion removal = 
comm-mode                = Linear
; number of steps for center of mass motion removal = 
nstcomm                  = 1
; group(s) for center of mass motion removal = 
;comm-grps                = 
nsttcouple               = 1
nstpcouple               = 1
; NEIGHBORSEARCHING PARAMETERS = 
; nblist update frequency = 
nstlist                  = 10
; ns algorithm (simple or grid) = 
ns_type                  = grid
; Periodic boundary conditions: xyz or no = 
pbc                      = xyz
; nblist cut-off         = 
rlist                    = 1.2

; OUTPUT CONTROL OPTIONS
; Output frequency for coords (x), velocities (v) and forces (f)
nstxout                  = 0
nstvout                  = 0
nstfout                  = 0
; Output frequency for energies to log file and energy file
nstlog                   = 500  ; changing this allows you to see the frequency the weights are computed.
nstcalcenergy            = 1
nstenergy                = 500
; Output frequency and precision for .xtc file
nstxout-compressed       = 500  ; change this to control how frequently the structures are printed out.
compressed-x-precision   = 1000

; OPTIONS FOR ELECTROSTATICS AND VDW = 
; Method for doing electrostatics = 
cutoff-scheme            = group
coulombtype              = PME
coulomb-modifier         = Potential-Switch
rcoulomb-switch          = 0.88
rcoulomb                 = 0.9

; Method for doing Van der Waals = 
vdw-type                 = Cut-off
vdw-modifier             = Potential-switch
; cut-off lengths        = 
rvdw-switch              = 0.85
rvdw                     = 0.9
; Apply long range dispersion corrections for Energy and Pressure = 
DispCorr                 = AllEnerPres
; Spacing for the PME/PPPM FFT grid = 
fourierspacing           = 0.12
; FFT grid size, when a value is 0 fourierspacing will be used = 
fourier_nx               = 0
fourier_ny               = 0
fourier_nz               = 0
; EWALD/PME/PPPM parameters = 
pme_order                = 4
ewald_rtol               = 1e-05
ewald_geometry           = 3d

; OPTIONS FOR BONDS     = 
constraints              = hbonds ; constrain bonds to hydrogen
; Type of constraint algorithm = 
constraint-algorithm     = shake
; Highest order in the expansion of the constraint coupling matrix = 
shake-tol                = 1e-12 ; 5e-6 ~TP

; GENERATE VELOCITIES FOR STARTUP RUN = 
gen_vel                  = yes
gen_temp                 = 300.0 ; K
gen_seed                 = {gen-seed}


; OPTIONS FOR WEAK COUPLING ALGORITHMS = 

; Groups to couple separately = 
tc-grps                  = System
; Time constant (ps) and reference temperature (K) = 
tcoupl                   = nose-hoover
tau_t                    = 0.5; 1.0 ~TP
ref_t                    = 300.0 

; Pressure coupling      = 
Pcoupl                   = MTTK
Pcoupltype               = isotropic
; Time constant (ps), compressibility (1/bar) and reference P (bar) = 
tau_p                    = 20.0 ; 5.0 ; ps ~TP
compressibility          = 4.5e-5 ; 1/bar
ref_p                    = 1.0 ; bar

; OPTIONS FOR EXPANDED ENSEMBLE SIMULATIONS
; Free energy control stuff  
free-energy               = {free-energy-flag}
sc-alpha                  = 0.5
couple-moltype            = {ligand}
couple-lambda0            = vdw-q
couple-lambda1            = none
couple-intramol           = no
fep-lambdas               = {fep-lambdas}
coul-lambdas              = {coul-lambdas}
vdw-lambdas               = {vdw-lambdas}
init_lambda_state         = {init-state-index}
symmetrized-transition-matrix = yes
nst-transition-matrix     = 100000
nstdhdl                   = 500
dhdl-print-energy         = total

; expanded ensemble
nstexpanded              = 50
lmc-stats                = wang-landau
lmc-move                 = metropolis
lmc-weights-equil        = {weights-equil}
{wed}weight-equil-wl-delta    = 0.001
lmc-seed                 = {lmc-seed}
{ilw}init-lambda-weights      = {wl-weights}

; Seed for Monte Carlo in lambda space
wl-scale                 = 0.5
wl-ratio                 = 0.8
init-wl-delta            = {incrementor:0.3f}
wl-oneovert              = yes
""".format(**fields)

    return text_

def generate(opts, submit=False, randseed=False):
    base_name = opts[KEYS.base_name]
    if not base_name:
        print('Base name not specified')
        return
    job_name = opts[KEYS.job_name]
    if not job_name:
        print('Job name not specified')
        return

    cur_dir = os.getcwd()
    dir_ = expandpath(opts[KEYS.script_dir])
    if not os.path.exists(dir_):
        os.mkdir(dir_)
    os.chdir(dir_)
    path = expandpath(opts[KEYS.work_dir])
    for i in range(opts[KEYS.mdr_count]):
        suffix = '_{0:0>2}'.format(i)
        if opts[KEYS.mdr_count] < 2:
            suffix = ''
        fields = dict()
        fields['base'] = base_name
        fields['job-name'] = job_name
        fields['suffix'] = suffix
        fields['path'] = path
        fields['ntasks'] = opts[KEYS.mdr_threads]
        fields['queue-time'] = opts[KEYS.mdr_queue_time]
        fields['gro-in'] = base_name + suffix
        fields['mdp-in'] = job_name + suffix
        if randseed:
            fields['gro-in'] = base_name
            try:
                import random
                # random.seed(0)
                seed = random.randint(0, 65536)
                fields['gen-seed'] = seed + i
                fields['lmc-seed'] = seed + i
                parameters(opts, name=fields['mdp-in'], fields=fields)
            except IOError as ioex:
                print(ioex)
        else:
            try:
                parameters(opts, name=job_name + suffix, fields=fields)
            except IOError as ioex:
                print(ioex)

        file_name = job_name + suffix + '.slurm'
        file_ = open(file_name, 'w')
        file_.write(place_simarray_vars(fields))
        file_.close()
        if submit:
            dir_name = os.path.join(path, job_name + suffix)
            if not os.path.exists(dir_name):
                os.mkdir(dir_name)
            # yes, this seems to be unnecessary, but it helps in debugging if
            #    directory doesn't actually have to exist to run without submit
            os.system("mv " + fields['mdp-in'] + ".mdp " +
                os.path.join(dir_name, fields['mdp-in']) + ".mdp")
            os.system("sbatch " + file_name)
            print("Sbatch'd Job " + job_name + suffix)

    os.chdir(cur_dir)

def parameters(opts, dir_='.', name=None, fields=None):
    job_name = opts[KEYS.job_name]
    if not job_name:
        print('Job name not specified')
        return

    if not name:
        name = job_name

    cur_dir = os.getcwd()
    dir_ = os.path.expandvars(os.path.expanduser(dir_))
    if not os.path.exists(dir_):
        os.mkdir(dir_)
    os.chdir(dir_)

    if not fields:
        fields = dict()
    fields['ligand'] = opts[KEYS.ligand]
    fields['time-ns'] = opts[KEYS.sim_time]
    fields['initial-weights'] = opts[KEYS.sim_weights]
    fields['fixed-weights'] = opts[KEYS.sim_fixed_weights]
    fields['fixed-lambda'] = opts[KEYS.sim_fixed_lambda]

    if not 'gen-seed' in fields:
        fields['gen-seed'] = 10200
    if not 'lmc-seed' in fields:
        fields['lmc-seed'] = 10200

    fields['fep'] = [0.0] * 18
    fields['coul'] = [0.0, 0.0, 0.0, 0.3, 0.5, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
        1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]
    fields['vdw'] = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1, 0.2, 0.3, 0.4, 0.5,
        0.6, 0.7, 0.8, 0.9, 1.0, 1.0, 1.0]
    fields['init-state-index'] = len(fields['fep']) - 1
    fields['weights'] = [0.00000, 0.00000, 0.00000, 1.28125, 2.05469, 3.20508,
        3.49414, 3.71484, 3.91797, 4.12695, 4.28906, 4.42773, 4.57812, 4.71289,
        4.81055, 4.88281, 4.74609, 4.78125]
    if opts[KEYS.sim_weight_values]:
        fields['weights'] = opts[KEYS.sim_weight_values]
    fields['incrementor'] = opts[KEYS.sim_incrementor]

    file_name = name + '.mdp'
    file_ = open(file_name, 'w')
    file_.write(place_simarray_mdp_vars(fields))
    file_.close()

    os.chdir(cur_dir)

def main(argv=None):
    if not argv:
        argv = sys.argv[1:]

    opts = option_defaults()

    parser = OptionParser(description=("Generates Rivanna SLURM scripts for" +
        " running Gromacs simulations"))
    parser.add_option("-v", "--verbose", help="Increase output frequency" +
        " and detail. Stacks three times.", action="count")
    parser.add_option("--par", help="Optional configuration file to specify" +
        " command line parameters and more.",
        default=None, metavar="file.par")
    parser.add_option("--slurm", help="""Prepare scripts to run on Rivanna""",
        default=None, action='store_true')
    parser.add_option("--mdp", help="Output the Molecular Dynamics Parameters" +
        " (.mdp) configuration file",
        default=None, action='store_true')
    parser.add_option("-n", help="""Job name for output""", metavar="sim")
    parser.add_option("-b", help="""Base name for job input""", metavar="sim")
    parser.add_option("--submit", action='store_true')

    if len(argv) < 1:
        parser.print_help()
        sys.exit(0)

    (options, _) = parser.parse_args(argv)

    # handle options, reading from file if requested
    if options.par:
        print('Reading parameters from ' + options.par)
        opts = parse_options(options.par, opts)
        if not opts:
            print('Error reading from parameters file.')
            sys.exit(1)

    global verbose  # ensure that we are talking about the same verbose here
    if options.verbose:
        verbose = options.verbose
    else:
        verbose = opts[KEYS.verbosity]
    opts[KEYS.verbosity] = verbose

    if options.n:
        opts[KEYS.job_name] = options.n
    if options.b:
        opts[KEYS.base_name] = options.b
    if options.mdp:
        opts[KEYS.setup_mdp] = options.mdp
    if options.slurm:
        opts[KEYS.setup_simarray] = options.slurm

    # output run options
    if opts[KEYS.job_name]:
        param_name = opts[KEYS.job_name] + _file_ext()
        param_out = backup_file('./', param_name)
    else:
        param_name = _file_ext()
        param_out = backup_file('', param_name)
    write_options(param_out, opts)

    # perform requested file output and job submissions
    if opts[KEYS.setup_mdp]:
        parameters(opts)
    if opts[KEYS.setup_simarray]:
        generate(opts, options.submit, randseed=opts[KEYS.mdr_genseed])

if __name__ == '__main__':
    main(sys.argv[1:])















